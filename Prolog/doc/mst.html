<!DOCTYPE html>
<html>
<head>
<title>mst.pl</title>

<link rel="stylesheet" type="text/css" href="pldoc.css">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">

</head>
<body>


<h1 class="file"><span style="float:right"></span>mst.pl</h1>

<dl>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="new_graph/1"><b class="pred">new_graph</b><var class="arglist">(+Graph:term)</var></a> is <b class="det">det</b></dt><dd class="defbody">Predicate that asserts a <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=graph/1">graph/1</a> <var>Graph</var> if not already existing
The predicate is always true

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- term to be asserted as graph </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="delete_graph/1"><b class="pred">delete_graph</b><var class="arglist">(+Graph:graph)</var></a> is <b class="det">det</b></dt><dd class="defbody">Predicate that retracts all <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a>, <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a> and <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=graph/1">graph/1</a> associated with
graph form the knowledge base <br>
The predicate is always true

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="new_vertex/2"><b class="pred">new_vertex</b><var class="arglist">(+Graph:graph, +Vertex:term)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that asserts a <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a> that associates <var>Graph</var> with <var>Vertex</var> if
not already associated <br>
The predicate is false if <var>Graph</var> is not a graph, else is true

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>Vertex</var></td><td class="argdescr">- term to be asserted as vertex </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="graph_vertices/2"><b class="pred">graph_vertices</b><var class="arglist">(+Graph:graph, -Vertices:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when <var>Vertices</var> contains every <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a> associated
with the graph <var>Graph</var> <br>
The predicate is false if <var>Graph</var> is not a graph

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>Vertices</var></td><td class="argdescr">- list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a> associated with <var>Graph</var>, empty if <var>Graph</var> is
an empty graph </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="list_vertices/1"><b class="pred">list_vertices</b><var class="arglist">(+Graph:graph)</var></a> is <b class="det">det</b></dt><dd class="defbody">Predicate that prints listing of all <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a> associated with the graph
<var>Graph</var> <br>
The predicate is always true

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="new_arc/4"><b class="pred">new_arc</b><var class="arglist">(+Graph:graph, +Source:vertex, +Destination:vertex, +Weight:number)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that asserts an <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> from <var>Source</var> to <var>Destination</var> in
the graph <br>
<var>Graph</var> with assigned weight <var>Weight</var> <br>
The predicate retracts any preexisting <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> joining <var>Source</var> and
<var>Destination</var>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>Source</var></td><td class="argdescr">- vertex the arc starts from</td></tr>
<tr><td><var>Destination</var></td><td class="argdescr">- vertex the arc arrives in</td></tr>
<tr><td><var>Weight</var></td><td class="argdescr">- weight of the arc </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="new_arc/3"><b class="pred">new_arc</b><var class="arglist">(+Graph:graph, +Source:vertex, +Destination:vertex)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Assumes weight of the arc is 1

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>Source</var></td><td class="argdescr">- vertex the arc starts from</td></tr>
<tr><td><var>Destination</var></td><td class="argdescr">- vertex the arc arrives in</td></tr>
</table>

</dd>
<dt class="keyword-see">See also</dt><dd class="keyword-see">- <a href="/pldoc/doc_for?object=user%3Anew_arc/4">new_arc/4</a> </dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="graph_arcs/2"><b class="pred">graph_arcs</b><var class="arglist">(+Graph:graph, -Arcs:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when <var>Arcs</var> is a list of all the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> associated
with the graph <var>Graph</var> <br>
The predicate is false when <var>Graph</var> is not a graph

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>Arcs</var></td><td class="argdescr">- list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> associated with <var>Graph</var>, empty if <var>Graph</var> is an
empty graph </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="vertex_neighbors/3"><b class="pred">vertex_neighbors</b><var class="arglist">(+Graph:graph, +Vertex:vertex, -Neighbors:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when <var>Neighbors</var> is the list of all the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> that
are incident to <var>Vertex</var> <br>
The predicate is false when <var>Vertex</var> is not a vertex associated with
<var>Graph</var> <br>
This predicate is to be used in an undirected graph context

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>Vertex</var></td><td class="argdescr">- end-point of the arcs in <var>Neighbors</var></td></tr>
<tr><td><var>Neighbors</var></td><td class="argdescr">- list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> that are incident to <var>Vertex</var>, with the
oreder of the arguments arranged to have <var>Vertex</var> as the second
argument regardless of the order they are arranged in the knowledge
base </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="vertex_neighbors_oriented/3"><b class="pred">vertex_neighbors_oriented</b><var class="arglist">(+Graph:graph, +Vertex:vertex, -Neighbors:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when <var>Neighbors</var> is the list of all the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> that
are have <var>Vertex</var> as tail <br>
The predicate is false when <var>Vertex</var> is not a vertex associated with
<var>Graph</var> <br>
This predicate is to be used in a directed graph context

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>Vertex</var></td><td class="argdescr">- tail of the arcs in <var>Neighbors</var></td></tr>
<tr><td><var>Neighbors</var></td><td class="argdescr">- list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> that have <var>Vertex</var> as tail </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="adjs/3"><b class="pred">adjs</b><var class="arglist">(+Graph:graph, +Vertex:vertex, -Adjacents:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when <var>Adjacents</var> is the list of all the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a>
that are joined to <var>Vertex</var> by an arc <br>
This predicate is to be used in an undirected graph context

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>Vertex</var></td><td class="argdescr">- vertex the arcs in <var>Adjacents</var> are joined to</td></tr>
<tr><td><var>Adjacents</var></td><td class="argdescr">- list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a> joined to <var>Vertex</var> by an arcs </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="adjs_oriented/3"><b class="pred">adjs_oriented</b><var class="arglist">(+Graph:graph, +Vertex:vertex, -Adjacents:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when <var>Adjacents</var> is the list of all the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a>
that are head to an arc having <var>Vertex</var> as tail <br>
This predicate is to be used in a directed graph context

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>Vertex</var></td><td class="argdescr">- vertex the arcs in <var>Adjacents</var> are joined to</td></tr>
<tr><td><var>Adjacents</var></td><td class="argdescr">- list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a> that are head of an arc having <var>Vertex</var>
as tail </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="list_arcs/1"><b class="pred">list_arcs</b><var class="arglist">(+Graph:graph)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that prints the listing of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> associated with G <br>
The predicate is false when <var>Graph</var> is not a graph

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="list_graph/1"><b class="pred">list_graph</b><var class="arglist">(+Graph:graph)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that prints the listing of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a>, <a class="builtin" href="http://www.swi-prolog.org/pldoc/man?predicate=vertices/2">vertices/2</a> <br>
The predicate is false when <var>Graph</var> is not a graph

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="read_graph/2"><b class="pred">read_graph</b><var class="arglist">(+Graph:graph, +FileName:path)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that reads <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> of <var>Graph</var> from a tab separated csv file,
every arc will be written as a triple {Source Destination Weight}
omitting the term representing the graph <br>
<var>Graph</var> will be asserted as graph if not already a graph <br>
Every vertex present as end-point of the arc will be asserted as
vertex of <var>Graph</var> <br>
Every arc will be asserted as arc of <var>Graph</var>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>FileName</var></td><td class="argdescr">- the path of the input csv file </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="read_graph/3"><b class="pred">read_graph</b><var class="arglist">(+Graph:graph, +FileName:path, +Separator:number)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that reads <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> of <var>Graph</var> from a <var>Separator</var> separated csv file,
every arc will be written as a triple {Source Destination Weight}
omitting the term representing the graph <br>
<var>Graph</var> will be asserted as graph if not already a graph <br>
Every vertex present as end-point of the arc will be asserted as
vertex of <var>Graph</var> <br>
Every arc will be asserted as arc of <var>Graph</var>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>FileName</var></td><td class="argdescr">- the path of the input csv file</td></tr>
<tr><td><var>Separator</var></td><td class="argdescr">- the ASCII code correspoing to the separator of the csv file </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="new_graph_from_rows/2"><b class="pred">new_graph_from_rows</b><var class="arglist">(+Graph:graph, +Rows:rows)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support predicate for <a href="/pldoc/doc_for?object=user%3Aread_graph/2">read_graph/2</a> <br>
Predicate to create a graph G given a list in
the format[<code>row(V, U, W)</code>] where V is source vertex, U is destination
vertex and W is weight of the arc between the two <br>
This Predicate asserts <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=graph/1">graph/1</a>, <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a>, <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> as needed to represent
the arcs described in <var>Rows</var>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>Rows</var></td><td class="argdescr">- list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=row/3">row/3</a> elements </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="write_graph/2"><b class="pred">write_graph</b><var class="arglist">(+Graph:graph, +FileName:path)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that writes <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> of <var>Graph</var> to a tab separated csv file,
every arc will be written as a triple {Source, Destination, Weight}
omitting the term representing the graph

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- graph object of the action</td></tr>
<tr><td><var>FileName</var></td><td class="argdescr">- the path of the output csv file </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="write_arcs_in_rows/2"><b class="pred">write_arcs_in_rows</b><var class="arglist">(+Arcs:list, -Rows:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support Predicate for <a href="/pldoc/doc_for?object=user%3Awrite_graph/2">write_graph/2</a> <br>
Predicate that is true when <var>Rows</var> is a list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=row/3">row/3</a> such that
for every <code>arc(G, V, U, W)</code> in <var>Arcs</var> it contains a <code>row(V, U, W)</code>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Arcs</var></td><td class="argdescr">- list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a></td></tr>
<tr><td><var>Rows</var></td><td class="argdescr">- list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=row/3">row/3</a> </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="new_heap/1"><b class="pred">new_heap</b><var class="arglist">(+Heap:term)</var></a> is <b class="det">det</b></dt><dd class="defbody">Predicate that asserts <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap/2">heap/2</a> associated with <var>Heap</var> if not already
existing<br>
This predicate is always true

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- the term to be asserted as heap </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="delete_heap/1"><b class="pred">delete_heap</b><var class="arglist">(+Heap:heap)</var></a> is <b class="det">det</b></dt><dd class="defbody">Predicate that retracts <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap/2">heap/2</a> and all <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> associated with
<var>Heap</var><br>
This predicate is always true

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heap_has_size/2"><b class="pred">heap_has_size</b><var class="arglist">(+Heap:heap, -Size:number)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when <var>Size</var> is the size of the heap <var>Heap</var>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action</td></tr>
<tr><td><var>Size</var></td><td class="argdescr">- size of the heap </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heap_empty/1"><b class="pred">heap_empty</b><var class="arglist">(+Heap:heap)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when <var>Heap</var> is a empty heap

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heap_not_empty/1"><b class="pred">heap_not_empty</b><var class="arglist">(+Heap:heap)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true if the <var>Heap</var> is a non-empty heap

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heap_head/3"><b class="pred">heap_head</b><var class="arglist">(+Heap:heap, -Key:number, -Value:term)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when the minimum key in the heap <var>Heap</var> is <var>Key</var> and
<var>Value</var> is the associated value

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action</td></tr>
<tr><td><var>Key</var></td><td class="argdescr">- key of the first element of the heap</td></tr>
<tr><td><var>Value</var></td><td class="argdescr">- value of the firt element of the heap </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heap_extract/3"><b class="pred">heap_extract</b><var class="arglist">(+Heap:heap, -Key:number, -Value:term)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when <var>Key</var>, <var>Value</var> are key and value of the head
of the heap <var>Heap</var><br>
This predicate changes the knowledge base removing the head from the
heap and restructuring the heap to mantain the heap property

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action</td></tr>
<tr><td><var>Key</var></td><td class="argdescr">- key of the head of the heap</td></tr>
<tr><td><var>Value</var></td><td class="argdescr">- value of the head of the heap </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heap_decrease_key/3"><b class="pred">heap_decrease_key</b><var class="arglist">(+Heap:heap, +Position:number, +NewKey:number)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support predicate for heap operations<br>
Predicate that changes the key of the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> with position
<var>Position</var> and moves it to a new position according to <var>NewKey</var> if <var>NewKey</var>
is lesser then the preexisting key, else the predicate fails

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action</td></tr>
<tr><td><var>Position</var></td><td class="argdescr">- index of the heap array indexing the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a></td></tr>
<tr><td><var>NewKey</var></td><td class="argdescr">- new value to be associated with the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heap_move_up/2"><b class="pred">heap_move_up</b><var class="arglist">(+Heap:heap, +Position:number)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support predicate for heap operations<br>
Predicate that moves a <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a>, in a heap <var>Heap</var> at position
<var>Position</var>, up until needed according to its key

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action</td></tr>
<tr><td><var>Position</var></td><td class="argdescr">- index of the heap array indexing the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heap_insert/3"><b class="pred">heap_insert</b><var class="arglist">(+Heap:heap, +Key:number, +Value:term)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that asserts a new <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> with key <var>Key</var> and value
<var>Value</var><br>
This predicate changes the knowledge base adding the new <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a>
in the heap and restructuring the heap to mantain the heap property

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action</td></tr>
<tr><td><var>Key</var></td><td class="argdescr">- the key of the new <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a></td></tr>
<tr><td><var>Value</var></td><td class="argdescr">- the value of the new <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heapify/2"><b class="pred">heapify</b><var class="arglist">(+Heap:heap, +Position:number)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that restructures the heap taking for granted the two
subtrees from P are already heaps

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action</td></tr>
<tr><td><var>Position</var></td><td class="argdescr">- index of the heap array to heapify </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heapify_on_different/3"><b class="pred">heapify_on_different</b><var class="arglist">(+Heap:heap, +To_heapify:number, +Position:number)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support predicate for heap operations<br>
Predicate that calls an <a href="/pldoc/doc_for?object=user%3Aheapify/2">heapify/2</a> on <var>To_heapify</var> if it is different from
<var>Position</var>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action</td></tr>
<tr><td><var>To_heapify</var></td><td class="argdescr">- index of the heap array to heapify</td></tr>
<tr><td><var>Position</var></td><td class="argdescr">- generally the position previosly heapified </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heap_switch/3"><b class="pred">heap_switch</b><var class="arglist">(+Heap:heap, +Position1:number, +Position2:number)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support predicate for heap operations<br>
Predicate that switches positions in <var>Heap</var>
between the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> at the given positions

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action</td></tr>
<tr><td><var>Position1</var></td><td class="argdescr">- position of the first <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a></td></tr>
<tr><td><var>Position2</var></td><td class="argdescr">- position of the second <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="modify_key/4"><b class="pred">modify_key</b><var class="arglist">(+Heap:heap, +NewKey:number, +OldKey:number, +Value:term)</var></a> is <b class="det">nondet</b></dt><dd class="defbody">Predicate replaces the a heap_entry with key <var>OldKey</var> and value <var>Value</var>
with one with <var>NewKey</var> as key and the same <var>Value</var><br>
This predicate changes the knowledge base changing the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> in
the heap and restructuring the heap to mantain the heap property<br>
This predicate is meant for a context with unique couple {key, value},
else it is expected to work fine and change all the unifing
<a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> but the feature is untested<br>
This predicate is meant to be used only for <var>NewKey</var> &gt; <var>OldKey</var> for
<a href="/pldoc/doc_for?object=user%3Aheap_decrease_key/3">heap_decrease_key/3</a> is way more efficient in <var>NewKey</var> =&lt; <var>OldKey</var> use case

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action</td></tr>
<tr><td><var>NewKey</var></td><td class="argdescr">- key to be assigned at <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a></td></tr>
<tr><td><var>OldKey</var></td><td class="argdescr">- key of preexisting <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a></td></tr>
<tr><td><var>Value</var></td><td class="argdescr">- value of preexisting <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="list_heap/1"><b class="pred">list_heap</b><var class="arglist">(+Heap:heap)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that prints the listing of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap/2">heap/2</a> and <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> associated
with heap <var>Heap</var>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="heap_contains/3"><b class="pred">heap_contains</b><var class="arglist">(+Heap:heap, +Key:number, +Value:term)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when the heap <var>Heap</var> contains the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a>
with key <var>Key</var> and value <var>Value</var>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- heap object of the action</td></tr>
<tr><td><var>Key</var></td><td class="argdescr">- key of the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a></td></tr>
<tr><td><var>Value</var></td><td class="argdescr">- value of the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="mst_prim/2"><b class="pred">mst_prim</b><var class="arglist">(+Graph:graph, +Source:vertex)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that determines the minimum spanning tree of a graph <var>Graph</var>
using <var>Source</var> as start vertex for Prim's algorithm<br>
This predicate asserts <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex_key/3">vertex_key/3</a> and <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex_previous/3">vertex_previous/3</a> describing
the mst

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- the graph object of the action</td></tr>
<tr><td><var>Source</var></td><td class="argdescr">- the starting vertex for Prim's algorithm </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="mst_prim/1"><b class="pred">mst_prim</b><var class="arglist">(+Graph:graph)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support predicate for <a href="/pldoc/doc_for?object=user%3Amst_prim/2">mst_prim/2</a><br>
Predicate that solves the Prim's algorithm after intialization <a href="/pldoc/doc_for?object=user%3Ainit/4">init/4</a> </dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="mst_get/3"><b class="pred">mst_get</b><var class="arglist">(+Graph:graph, +Source:vertex, -PreorderTree:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that is true when <var>PreorderTree</var> is the list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a>
composing the minimum spanning tree of the graph <var>Graph</var> starting from
<var>Source</var><br>
This predicate is supposed to be called after <code>mst_prim(Graph, Source)</code>
for it's based on its assertions, notice that the <var>Source</var> vertex has to
be the same to avoid unexpected behaviour

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- the graph object of the action</td></tr>
<tr><td><var>Source</var></td><td class="argdescr">- the starting vertex for Prim's algorithm</td></tr>
<tr><td><var>PreorderTree</var></td><td class="argdescr">- <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> enocuntered during a preoder visit of the tree </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="mst_get_neighbors/3"><b class="pred">mst_get_neighbors</b><var class="arglist">(+Graph:graph, +Source:vertex, -Neighbors:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support predicate for <a href="/pldoc/doc_for?object=user%3Amst_get/3">mst_get/3</a><br>
Predicate that finds the list <var>Neighbors</var> <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> of a <var>Source</var> vertex
according to the minimum spanning tree of the graph <var>Graph</var>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- the graph object of the action</td></tr>
<tr><td><var>Source</var></td><td class="argdescr">- the vertex object of the action</td></tr>
<tr><td><var>Neighbors</var></td><td class="argdescr">- list of neighbors <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> of <var>Source</var> </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="build_arcs_from_list/2"><b class="pred">build_arcs_from_list</b><var class="arglist">(+List:list, -Arcs:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support predicate for graph operations
Predicate that is true when each element [G, V, U, W] of <var>List</var>
corresponds to an <code>arc(G, V, U, W)</code> with the same position in <var>Arcs</var>

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>List</var></td><td class="argdescr">- list of [G, V, U, W] arguments of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a></td></tr>
<tr><td><var>Arcs</var></td><td class="argdescr">- list of composed <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="mst_get_recurse/2"><b class="pred">mst_get_recurse</b><var class="arglist">(+Arcs:list, -PreorderTree:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support predicate for <a href="/pldoc/doc_for?object=user%3Amst_get/3">mst_get/3</a><br>
Predicate that is true when <var>PreorderTree</var> is the list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> visited
in the minimum spanning tree in a preorder visit, with <var>Arcs</var> being
the neighbors arcs

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Arcs</var></td><td class="argdescr">- list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a></td></tr>
<tr><td><var>PreorderTree</var></td><td class="argdescr">- <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> enocuntered during a preoder visit of the tree </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="init/4"><b class="pred">init</b><var class="arglist">(+Heap:term, +Graph:graph, +Vertices:list, +Source:vertex)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support predicate for <a href="/pldoc/doc_for?object=user%3Amst_prim/2">mst_prim/2</a><br>
Predicate that initializes <var>Heap</var> as a heap for the Prim's algorithm,
with a list <var>Vertices</var> containing all the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a> of a graph <var>Graph</var><br>
This predicate asserts a <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap_entry/4">heap_entry/4</a> for each vertex assigning inf as
key except for the <var>Source</var> vertex which is given key 0

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- term to be asserted as <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=heap/2">heap/2</a></td></tr>
<tr><td><var>Graph</var></td><td class="argdescr">- the graph object of the action</td></tr>
<tr><td><var>Vertices</var></td><td class="argdescr">- list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex/2">vertex/2</a> in <var>Graph</var></td></tr>
<tr><td><var>Source</var></td><td class="argdescr">- starting vertex for Prim's algorithm </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="update_keys/2"><b class="pred">update_keys</b><var class="arglist">(+Heap:heap, +Arcs:list)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Support predicate for <a href="/pldoc/doc_for?object=user%3Amst_prim/2">mst_prim/2</a><br>
Predicate that takes a list of <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> <var>Arcs</var> with a common head in the
graph Graph and asserts a new <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex_key/3">vertex_key/3</a>, retracting a
pre-exisisting one, for each <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a> in arcs if the weight of the <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=arc/4">arc/4</a>
is less than the one in the existing <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex_key/3">vertex_key/3</a> and if the
<a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex_key/3">vertex_key/3</a> is still in the heap <var>Heap</var><br>
The predicate also updates the key in the heap

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Heap</var></td><td class="argdescr">- the heap containing the verices</td></tr>
<tr><td><var>Arcs</var></td><td class="argdescr">- list of arcs used to update the keys </td></tr>
</table>

</dd>
</dl>

</dd>
<dt class="pubdef"><span style="float:right">&nbsp;</span><a name="mst_reset/1"><b class="pred">mst_reset</b><var class="arglist">(+Graph:graph)</var></a> is <b class="det">semidet</b></dt><dd class="defbody">Predicate that retracts all data asserted by a <a href="/pldoc/doc_for?object=user%3Amst_prim/2">mst_prim/2</a><br>
This predicate retracts all <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex_key/3">vertex_key/3</a>, <a class="extmanual" href="http://www.swi-prolog.org/pldoc/man?predicate=vertex_previous/3">vertex_previous/3</a> and
deletes the heap

<dl class="tags">
<dt class="tag">Arguments:</dt><dd>

<table class="arglist">
<tr><td><var>Graph</var></td><td class="argdescr">- the graph object of the action </td></tr>
</table>

</dd>
</dl>

</dd>
</dl>

</body>
</html>
